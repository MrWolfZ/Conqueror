using System.ComponentModel.DataAnnotations;
using Conqueror;

namespace Quickstart;

// The handler type is also enhanced by the Conqueror source generator, so it must be partial
internal sealed partial class IncrementCounterByAmountHandler(
        CountersRepository repository,
        ISignalPublishers publishers)

    // This interface (among other things) is generated by a source generator
    : IncrementCounterByAmount.IHandler
{
    // Configure a pipeline of middlewares which is executed for every message
    public static void ConfigurePipeline(IncrementCounterByAmount.IPipeline pipeline) =>
        pipeline

            // Conqueror ships with a handful of useful middleware packages
            // for common cross-cutting concerns like logging and authorization
            .UseLogging(o => o.MessagePayloadLoggingStrategy = PayloadLoggingStrategy.IndentedJson)

            // Pipelines can have inline middlewares for ad-hoc logic (or you can
            // build a full-fledged middleware; see the recipes for more details)
            .Use(ctx =>
            {
                // Perform a simple data annotation validation (in a real application you would
                // likely use a more powerful validation library like FluentValidation)
                Validator.ValidateObject(ctx.Message, new(ctx.Message), true);

                // Note that the middleware has access to the message with its proper type(i.e.
                // the compiler knows that `ctx.Message` is of type `IncrementCounterByAmount`),
                // so you could also write the validation directly like this:
                if (ctx.Message.IncrementBy <= 0)
                {
                    throw new ArgumentOutOfRangeException(nameof(ctx.Message.IncrementBy),
                                                          "increment amount must be positive");
                }

                return ctx.Next(ctx.Message, ctx.CancellationToken);
            })

            // Middlewares which have been added to a pipeline can be configured further
            .ConfigureLogging(o => o.ExceptionLogLevel = LogLevel.Critical);

    public async Task<CounterIncrementedResponse> Handle(
        IncrementCounterByAmount message,
        CancellationToken cancellationToken = default)
    {
        var newValue = await repository.AddOrIncrementCounter(message.CounterName,
                                                              message.IncrementBy);

        // `ISignalPublishers` is a factory to get a publisher for a signal type. The
        // `CounterIncremented.T` property is generated by the source generator and is used for
        // type inference. The 'For' method returns a `CounterIncremented.IHandler` (which is a
        // proxy for the actual signal handlers)
        await publishers.For(CounterIncremented.T)

                        // You can customize the transport which is used to publish the signal
                        // (e.g. sending it via RabbitMQ), but here we configure the in-process
                        // transport to use parallel broadcasting for demonstration (instead of
                        // the default sequential broadcasting). You can also pass your own custom
                        // strategy if you need it
                        .WithTransport(b => b.UseInProcessWithParallelBroadcastingStrategy())

                        // The 'Handle' method is unique for each `IHandler`. This means that your
                        // IDE's "Go to Implementation" feature will show all signal handlers for
                        // this signal, making it simple to find all the places in your code where
                        // a signal is used
                        .Handle(new(message.CounterName, newValue, message.IncrementBy),
                                cancellationToken);

        return new(await repository.GetCounterValue(message.CounterName));
    }
}
