using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;

namespace Conqueror.SourceGenerators.Messaging.Transport.Http;

[SuppressMessage("Style", "IDE0058:Expression value is never used", Justification = "this is common for working with string builders")]
public static class HttpMessageAbstractionsGenerationHelper
{
    private const string Header = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Conqueror.SourceGenerators source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable";

    public static (string Content, string FileName) GenerateMessageTypes(in HttpMessageTypeToGenerate typesToGenerate)
    {
        var sb = new StringBuilder();
        sb.AppendLine(Header);

        GenerateType(sb, in typesToGenerate);

        var content = sb.ToString();
        sb.Clear();

        var filename = sb
                       .Append(typesToGenerate.MessageTypeToGenerate.MessageTypeDescriptor.FullyQualifiedName)
                       .Append("_HttpMessageTypes.g.cs")
                       .Replace('<', '_')
                       .Replace('>', '_')
                       .Replace(',', '.')
                       .Replace(' ', '_')
                       .ToString();

        return new(content, filename);
    }

    [SuppressMessage("StyleCop.CSharp.SpacingRules", "SA1012:Opening braces should be spaced correctly", Justification = "false positive")]
    [SuppressMessage("StyleCop.CSharp.SpacingRules", "SA1013:Closing braces should be spaced correctly", Justification = "false positive")]
    private static void GenerateType(StringBuilder sb, in HttpMessageTypeToGenerate typesToGenerate)
    {
        var messageTypeDescriptor = typesToGenerate.MessageTypeToGenerate.MessageTypeDescriptor;
        var responseTypeDescriptor = typesToGenerate.MessageTypeToGenerate.ResponseTypeDescriptor;

        var messageTypeName = messageTypeDescriptor.Name;
        var responseTypeName = responseTypeDescriptor?.Name ?? "UnitMessageResponse";

        sb.Append("""

                  using Conqueror;

                  """);

        if (!string.IsNullOrEmpty(messageTypeDescriptor.Namespace))
        {
            sb.Append("""

                      namespace 
                      """)
              .Append(messageTypeDescriptor.Namespace)
              .Append("""

                      {
                      """);
        }

        var parentsCount = 0;
        var parentClass = messageTypeDescriptor.ParentClass;

        // TODO: proper indentation
        while (parentClass is not null)
        {
            sb.Append("\n    partial ")
              .Append(parentClass.Keyword) // e.g. class/struct/record
              .Append(' ')
              .Append(parentClass.Name) // e.g. Outer/Generic<T>
              .Append(' ')
              .Append(parentClass.Constraints) // e.g. where T: new()
              .AppendLine("""
                          
                              {
                          """);

            parentsCount += 1;
            parentClass = parentClass.Child;
        }

        var fullyQualifiedName = $"global::{messageTypeDescriptor.FullyQualifiedName}";

        sb.Append("""
                  
                      /// <summary>
                      ///     HTTP message types for <see cref="
                  """)
          .Append(fullyQualifiedName)
          .Append("""
                  " />
                      /// </summary>
                      
                  """)
          .Append("partial ")
          .Append(messageTypeDescriptor.IsRecord ? "record " : "class ")
          .Append(messageTypeDescriptor.Name);

        if (responseTypeDescriptor is not null)
        {
            // TODO: improve performance by not using templated strings
            sb.Append($" : IHttpMessage<{messageTypeName}, {responseTypeName}>");
        }
        else
        {
            // TODO: improve performance by not using templated strings
            sb.Append($" : IHttpMessage<{messageTypeName}>");
        }

        sb.Append("""
                  
                      {
                  """);

        if (typesToGenerate.HttpMethod is { } method)
        {
            sb.Append($$$"""
                         
                                 public static string HttpMethod { get; } = "{{{method}}}";

                         """);
        }

        if (typesToGenerate.PathPrefix is { } pathPrefix)
        {
            sb.Append($$$"""
                         
                                 public static string PathPrefix { get; } = "{{{pathPrefix}}}";

                         """);
        }

        if (typesToGenerate.Path is { } path)
        {
            sb.Append($$$"""
                         
                                 public static string Path { get; } = "{{{path}}}";

                         """);
        }

        if (typesToGenerate.FullPath is { } fullPath)
        {
            sb.Append($$$"""
                         
                                 public static string FullPath { get; } = "{{{fullPath}}}";

                         """);
        }

        if (typesToGenerate.Version is { } version)
        {
            sb.Append($$$"""
                         
                                 public static string Version { get; } = "{{{version}}}";

                         """);
        }

        if (typesToGenerate.SuccessStatusCode is { } successStatusCode)
        {
            sb.Append($$$"""
                         
                                 public static int SuccessStatusCode { get; } = {{{successStatusCode}}};

                         """);
        }

        if (typesToGenerate.Name is { } name)
        {
            sb.Append($$$"""
                         
                                 public static string Name { get; } = "{{{name}}}";

                         """);
        }

        if (typesToGenerate.ApiGroupName is { } groupName)
        {
            sb.Append($$$"""
                         
                                 public static string ApiGroupName { get; } = "{{{groupName}}}";

                         """);
        }

        sb.Append($$$"""
                     
                             static global::Conqueror.IHttpMessageTypesInjector global::Conqueror.IHttpMessage.HttpMessageTypesInjector
                                 => global::Conqueror.HttpMessageTypesInjector<{{{messageTypeName}}}, {{{responseTypeName}}}>.Default;
                     """);

        // only support query strings for GET messages; this also helps prevent
        // bugs in the generator for complex types from affecting too many message
        // types, and in case there is a bug for a complex GET message, the user can
        // always implement their own query string parsing
        if (typesToGenerate.HttpMethod is "GET")
        {
            sb.AppendLine();

            // TODO: nested properties
            // TODO: ignore if property is already defined to allow custom user code
            GenerateMessageSerializer(sb, messageTypeDescriptor, responseTypeName);
        }

        sb.Append("""
                  
                      }
                  """);

        for (var i = 0; i < parentsCount; i += 1)
        {
            sb.Append("""
                      
                          }
                      """);
        }

        if (!string.IsNullOrEmpty(messageTypeDescriptor.Namespace))
        {
            sb.Append("""

                      }

                      """);
        }
    }

    private static void GenerateMessageSerializer(StringBuilder sb, TypeDescriptor messageTypeDescriptor, string responseTypeName)
    {
        sb.AppendLine();
        sb.Append("        static global::Conqueror.IHttpMessageSerializer<").Append(messageTypeDescriptor.Name)
          .Append(", ").Append(responseTypeName).Append(">? global::Conqueror.IHttpMessage<").Append(messageTypeDescriptor.Name)
          .Append(", ").Append(responseTypeName).Append(">.HttpMessageSerializer").AppendLine();
        sb.Append("            => new global::Conqueror.HttpMessageQueryStringSerializer<").Append(messageTypeDescriptor.Name).Append(", ")
          .Append(responseTypeName).Append(">(").AppendLine();

        GenerateFromQueryStringFn(sb, messageTypeDescriptor);
        GenerateToQueryStringFn(sb, messageTypeDescriptor);

        sb.Append(");").AppendLine();
    }

    private static void GenerateFromQueryStringFn(StringBuilder sb, TypeDescriptor typeDescriptor)
    {
        // TODO: primary constructors support

        sb.Append("                query =>").AppendLine();
        sb.Append("                {").AppendLine();
        sb.Append("                    if (query is null)").AppendLine();
        sb.Append("                    {").AppendLine();
        sb.Append("                        throw new global::System.ArgumentException(\"query must not be null\", nameof(query));").AppendLine();
        sb.Append("                    }").AppendLine();
        sb.AppendLine();

        // Object initialization
        sb.Append("                    return new ").Append(typeDescriptor.Name).AppendLine();
        sb.Append("                    {").AppendLine();

        var isFirstProperty = true;
        var seenArray = false;

        foreach (var (propertyName, fullyQualifiedTypeName, isPrimitive, _, isString, enumerableDescriptor) in typeDescriptor.Properties)
        {
            if (!isFirstProperty)
            {
                sb.AppendLine();
            }

            sb.Append("                        ").Append(propertyName).Append(" = ");

            if (isPrimitive)
            {
                // Handle primitive values
                sb.Append("query.TryGetValue(\"").Append(Uncapitalize(propertyName)).Append("\", out var ").Append(Uncapitalize(propertyName)).Append("Values) && ")
                  .Append(Uncapitalize(propertyName)).Append("Values.Count > 0 && ").Append(Uncapitalize(propertyName)).Append("Values[0] is { } ").Append(Uncapitalize(propertyName)).Append("Value ")
                  .Append("? ")
                  .Append("(").Append(fullyQualifiedTypeName).Append(")global::System.Convert.ChangeType(").Append(Uncapitalize(propertyName)).Append("Value, typeof(")
                  .Append(fullyQualifiedTypeName).Append("))").Append(isString ? " : string.Empty" : " : default");
            }
            else if (enumerableDescriptor is { } enumerable)
            {
                var itemPropertyTypeName = enumerable.FullyQualifiedItemTypeName;

                if (!enumerable.IsPrimitive)
                {
                    itemPropertyTypeName = "global::" + itemPropertyTypeName;
                }

                if (enumerable.IsArray)
                {
                    seenArray = true;
                    sb.Append("ToArray(");
                }

                // Handle enumerable values
                sb.Append("query.TryGetValue(\"").Append(Uncapitalize(propertyName)).Append("\", out var ").Append(Uncapitalize(propertyName)).Append("Values) ")
                  .Append("? new global::System.Collections.Generic.List<").Append(itemPropertyTypeName).Append(">(");

                if (enumerable.IsPrimitive)
                {
                    sb.Append(Uncapitalize(propertyName)).Append("Values.ConvertAll(v => (").Append(itemPropertyTypeName).Append(")global::System.Convert.ChangeType(v, typeof(").Append(itemPropertyTypeName).Append(")))) ");
                }
                else
                {
                    sb.Append(Uncapitalize(propertyName)).Append("Values)");
                }

                sb.Append(": new global::System.Collections.Generic.List<").Append(itemPropertyTypeName).Append(">()");

                if (enumerable.IsArray)
                {
                    sb.Append(")");
                }
            }
            else
            {
                sb.Append("default!");
            }

            sb.AppendLine(",");

            isFirstProperty = false;
        }

        sb.Append("                    };").AppendLine();

        if (seenArray)
        {
            sb.AppendLine();
            sb.AppendLine("""
                          
                                          static T[] ToArray<T>(global::System.Collections.Generic.IList<T> iList)
                                          {
                                              var result = new T[iList.Count];
                                              iList.CopyTo(result, 0);
                                              return result;
                                          }
                          """);
        }

        sb.Append("                },").AppendLine();
    }

    private static void GenerateToQueryStringFn(StringBuilder sb, TypeDescriptor typeDescriptor)
    {
        sb.Append("                message =>").AppendLine();
        sb.Append("                {").AppendLine();
        sb.Append("                    global::System.Text.StringBuilder queryBuilder = new global::System.Text.StringBuilder();").AppendLine();

        var isFirst = true;
        var seenFirstProperty = false;
        var firstPropertyWasEnumerable = false;
        foreach (var property in typeDescriptor.Properties)
        {
            sb.AppendLine();

            var objAccess = "message." + property.Name;

            if (property.IsPrimitive)
            {
                var separator = seenFirstProperty
                    ? firstPropertyWasEnumerable
                        ? "queryBuilder.Length == 0 ? '?' : '&'"
                        : "'&'"
                    : "'?'";

                sb.Append("                    queryBuilder.Append(").Append(separator).Append(");").AppendLine();
                sb.Append("                    queryBuilder.Append(\"").Append(Uncapitalize(property.Name)).Append("=\");").AppendLine();
                sb.Append("                    queryBuilder.Append(global::System.Uri.EscapeDataString(").Append(objAccess).Append(property.IsNullable ? "?" : string.Empty).Append(".ToString() ?? string.Empty));").AppendLine();

                seenFirstProperty = true;
                continue;
            }

            if (property.Enumerable is { } enumerable)
            {
                firstPropertyWasEnumerable = isFirst;

                sb.Append("                    if (").Append(objAccess).AppendLine(" is not null)");
                sb.Append("                    {").AppendLine();
                sb.Append("                        foreach (var item in ").Append(objAccess).AppendLine(")");
                sb.Append("                        {").AppendLine();

                if (enumerable.IsNullable)
                {
                    sb.Append("                            if (item is not null)").AppendLine();
                    sb.Append("                            {").AppendLine();
                }

                var separator = seenFirstProperty ? "\"&\"" : "queryBuilder.Length == 0 ? \"?\" : \"&\"";

                sb.Append("                                queryBuilder.Append(").Append(separator).Append(");").AppendLine();
                sb.Append("                                queryBuilder.Append(\"").Append(Uncapitalize(property.Name)).Append("=\");").AppendLine();
                sb.Append("                                queryBuilder.Append(global::System.Uri.EscapeDataString(item").Append(enumerable.IsNullable ? "?" : string.Empty).Append(".ToString() ?? \"\"));").AppendLine();

                if (enumerable.IsNullable)
                {
                    sb.Append("                            }").AppendLine();
                }

                sb.Append("                        }").AppendLine();
                sb.Append("                    }").AppendLine();
            }

            isFirst = false;
        }

        sb.AppendLine();
        sb.Append("                    return queryBuilder.ToString();").AppendLine();
        sb.Append("                }");
    }

    private static string Uncapitalize(string str)
        => char.ToLower(str[0], CultureInfo.InvariantCulture) + str.Substring(1);
}
