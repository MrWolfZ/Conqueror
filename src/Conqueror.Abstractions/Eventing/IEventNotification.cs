using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json.Serialization;

// ReSharper disable once CheckNamespace
namespace Conqueror;

/// <summary>
///     This interface does not need to be added manually to user code. It is
///     generated by the source generator and is used by Conqueror APIs to infer
///     the types.
/// </summary>
/// <typeparam name="TEventNotification">the event notification type</typeparam>
public interface IEventNotification<
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)]
    TEventNotification>
    where TEventNotification : class, IEventNotification<TEventNotification>
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    static abstract IDefaultEventNotificationTypesInjector DefaultTypeInjector { get; }

    [EditorBrowsable(EditorBrowsableState.Never)]
    static abstract IReadOnlyCollection<IEventNotificationTypesInjector> TypeInjectors { get; }

    /// <summary>
    ///     This helper property can be used for type inference instead of having
    ///     to provide the generic event notification type argument.
    /// </summary>
    static abstract EventNotificationTypes<TEventNotification> T { get; }

    /// <summary>
    ///     Some transports must be able to construct an instance of this event notification
    ///     if it has no properties, but since this is only known to the actual
    ///     type, we cannot use the generic type constraint 'new()'. Instead, we
    ///     generate an empty instance in the source generator if the event notification type
    ///     does not have any properties.
    /// </summary>
    static abstract TEventNotification? EmptyInstance { get; }

    /// <summary>
    ///     The <see cref="System.Text.Json.Serialization.JsonSerializerContext" />
    ///     to use by default for any operation that needs to JSON-serialize or
    ///     deserialize an event notification of type <see cref="TEventNotification" />.<br />
    ///     <br />
    ///     When this is <c>null</c> and dynamic code generation is enabled (i.e.
    ///     the app is not running with AOT) then the serialization will use a default
    ///     context depending on where it is being used.
    /// </summary>
    static virtual JsonSerializerContext? JsonSerializerContext => null;

    [EditorBrowsable(EditorBrowsableState.Never)]
    static virtual IEnumerable<PropertyInfo> PublicProperties => typeof(TEventNotification).GetProperties(BindingFlags.Public | BindingFlags.Instance);
}

/// <summary>
///     This helper class is only used for enhanced type inference.
/// </summary>
/// <typeparam name="TEventNotification">the event notification type</typeparam>
public sealed class EventNotificationTypes<TEventNotification>
    where TEventNotification : class, IEventNotification<TEventNotification>
{
    public static readonly EventNotificationTypes<TEventNotification> Default = new();

    private EventNotificationTypes()
    {
    }
}
